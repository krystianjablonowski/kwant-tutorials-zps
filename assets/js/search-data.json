{
  
    
        "post0": {
            "title": "Title",
            "content": "!pip3 install kwant . Collecting kwant Downloading kwant-1.4.2.tar.gz (1.7 MB) |████████████████████████████████| 1.7 MB 33.7 MB/s Requirement already satisfied: numpy&gt;=1.11.0 in /usr/local/lib/python3.7/dist-packages (from kwant) (1.21.5) Requirement already satisfied: scipy&gt;=0.17.0 in /usr/local/lib/python3.7/dist-packages (from kwant) (1.4.1) Collecting tinyarray&gt;=1.2 Downloading tinyarray-1.2.4.tar.gz (37 kB) Building wheels for collected packages: kwant, tinyarray Building wheel for kwant (setup.py) ... done Created wheel for kwant: filename=kwant-1.4.2-cp37-cp37m-linux_x86_64.whl size=3774892 sha256=af84f0a3042cf2a9e021fd22082868d64a008d168ff329074ce51aa13d9830a4 Stored in directory: /root/.cache/pip/wheels/3e/a5/99/2e39c66ab8c9158d0a50da43c7e414252c2c5c23871a38b27d Building wheel for tinyarray (setup.py) ... done Created wheel for tinyarray: filename=tinyarray-1.2.4-cp37-cp37m-linux_x86_64.whl size=227995 sha256=40733ec3501f977a7bb5aa89691552f593ba27722e2e069013ff24882f3ab03a Stored in directory: /root/.cache/pip/wheels/85/c6/1c/6939e2931cfbff5df75758a06084bf67171b640ebdf5febd35 Successfully built kwant tinyarray Installing collected packages: tinyarray, kwant Successfully installed kwant-1.4.2 tinyarray-1.2.4 . import numpy as np import kwant from numpy import pi from scipy import sparse as sp from scipy.sparse import linalg as lsp from scipy import linalg as la from matplotlib import pyplot as plt %matplotlib inline . /usr/local/lib/python3.7/dist-packages/kwant/solvers/default.py:18: RuntimeWarning: MUMPS is not available, SciPy built-in solver will be used as a fallback. Performance can be very poor in this case. &#34;Performance can be very poor in this case.&#34;, RuntimeWarning) . kwant.__version__ . &#39;1.4.2&#39; . from tinyarray import array as ta # Pauli matrices sigma0 = ta([[1, 0], [0, 1]]) sigmax = ta([[0, 1], [1, 0]]) sigmay = ta([[0, -1j], [1j, 0]]) sigmaz = ta([[1, 0], [0, -1]]) . lat = kwant.lattice.square() syst = kwant.Builder(kwant.TranslationalSymmetry((-1, 0))) Wy = 100 def hop_x(to_site, from_site, t, B): x, y = to_site.pos return -t * np.exp(1j * B * (y-(Wy-1)/2)) * sigma0 def hop_y(to_site, from_site, t): x, y = to_site.pos return -t * sigma0 def onsite(site, t): x, y = site.pos return 4 * t * sigma0 # onsite for ny in range(Wy): syst[lat(0, ny)] = onsite # x-direction hoppings for ny in range(0,Wy): syst[lat(0,ny),lat(1,ny)] = hop_x # y-direction hoppings for ny in range(1,Wy): syst[lat(0,ny-1),lat(0,ny)] = hop_y ## PBC boundary: be very carefull to add properly if needed syst[lat(0, Wy-1), lat(0, 0)] = hop_y fsyst = syst.finalized() fig, ax = plt.subplots(1, 1) ax.set_xlabel(&quot;momentum&quot;) ax.set_ylabel(&quot;energy&quot;) ax.set_ylim(-0.01, 0.2) Bcrit = 2*np.pi/Wy params = dict( B=Bcrit/3, t=1/8) kwant.plotter.bands(fsyst, ax=ax, params=params) ax.grid() . #### dictionary containing the parameters params = dict( t = 1/8, B = Bcrit/3 ) ## Lead bands: calculation with a better control # sparse matrix diagonlization # prepare H_0 and V for our lead ham0 = fsyst.cell_hamiltonian(params=params, sparse=True) #.tocsc() _hop = fsyst.inter_cell_hopping(params=params, sparse=True) shp = (_hop.shape[0], _hop.shape[0] - _hop.shape[1]) _zeros = sp.coo_matrix( shp, dtype=complex) vhop = sp.hstack( [_hop, _zeros] ) #.tocsc() momenta=np.linspace(-np.pi, np.pi, 301) ens = [] for kpar in momenta: # H_k = H_0 + V e^-ik + V^ dagger e^ik hmat = vhop * np.exp(-1j*(kpar)) hmat += hmat.conjugate().transpose() + ham0 #evals = la.eigh( hmat, eigvals_only=True ) ## dense solver evals = lsp.eigsh( hmat, k=20, return_eigenvectors=False, which=&#39;LM&#39;, sigma=0.01, tol=10**(-8) ) ens.append(np.sort(evals)) plt.grid() #plt.xlim(-1, 1) plt.ylim(-0.01, 0.2) plt.xlabel(&#39;momentum [1/a]&#39;) plt.ylabel(&#39;energy&#39;) #plt.plot(momenta,ens,&#39;.&#39;,ms=1) plt.plot(momenta,ens) plt.show() .",
            "url": "https://korsakjakub.github.io/kwant-tutorials-zps/2022/06/07/ribbon_dispersion.html",
            "relUrl": "/2022/06/07/ribbon_dispersion.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Lieb model",
            "content": "import kwant import matplotlib.pyplot as plt import scipy.sparse.linalg as sla import scipy as scp import numpy as np from kwant.physics import dispersion . def make_system(a=1, t_1=1.0, t_2=1.0, L=10): lat = kwant.lattice.Polyatomic([[2*a, 0],[0,2*a]], [[0, 0],[0,a],[a,0]],norbs=1) lat.a, lat.b, lat.c = lat.sublattices syst = kwant.Builder() # Onsites syst[(lat.a(n,m) for n in range(L) for m in range(L))] = 0 syst[(lat.b(n,m) for n in range(L) for m in range(L))] = 0 syst[(lat.c(n,m) for n in range(L) for m in range(L))] = 0 # Hopping t1 syst[((lat.a(n,m), lat.b(n,m)) for n in range(L) for m in range(L))] = t_1 syst[((lat.a(n,m), lat.c(n,m)) for n in range(L) for m in range(L))] = t_1 syst[((lat.b(n,m), lat.c(n,m)) for n in range(L) for m in range(L))] = t_2 syst[((lat.b(n+1,m), lat.c(n,m)) for n in range(L-1) for m in range(L))] = t_2 syst[((lat.b(n,m-1), lat.c(n,m)) for n in range(L) for m in range(1,L))] = t_2 syst[((lat.b(n-1,m+1), lat.c(n,m)) for n in range(1,L) for m in range(L-1))] = t_2 syst[((lat.b(n,m), lat.a(n,m+1)) for n in range(L) for m in range(L-1))] = t_1 syst[((lat.c(n,m), lat.a(n+1,m)) for n in range(L-1) for m in range(L))] = t_1 # Hopping t2 # syst[((lat.b(n-1), lat.a(n)) for n in range(1,L))] = t_1 # Left lead sym_left_lead = kwant.TranslationalSymmetry([-2*a, 0]) left_lead = kwant.Builder(sym_left_lead) # Onsites left_lead[(lat.a(n,m) for n in range(L) for m in range(L))] = 0 left_lead[(lat.b(n,m) for n in range(L) for m in range(L))] = 0 left_lead[(lat.c(n,m) for n in range(L) for m in range(L))] = 0 # Hopping t1 left_lead[((lat.a(n,m), lat.b(n,m)) for n in range(L) for m in range(L))] = t_1 left_lead[((lat.a(n,m), lat.c(n,m)) for n in range(L) for m in range(L))] = t_1 left_lead[((lat.b(n,m), lat.c(n,m)) for n in range(L) for m in range(L))] = t_2 left_lead[((lat.b(n+1,m), lat.c(n,m)) for n in range(L-1) for m in range(L))] = t_2 left_lead[((lat.b(n,m-1), lat.c(n,m)) for n in range(L) for m in range(1,L))] = t_2 left_lead[((lat.b(n-1,m+1), lat.c(n,m)) for n in range(1,L) for m in range(L-1))] = t_2 left_lead[((lat.b(n,m), lat.a(n,m+1)) for n in range(L) for m in range(L-1))] = t_1 left_lead[((lat.c(n,m), lat.a(n+1,m)) for n in range(L-1) for m in range(L))] = t_1 syst.attach_lead(left_lead) left_lead_fin = left_lead.finalized() syst.attach_lead(left_lead.reversed()) # Right lead #sym_right_lead = kwant.TranslationalSymmetry([2*a, 0]) #right_lead = kwant.Builder(sym_right_lead) #right_lead[lat.a(0)] = 0 #right_lead[lat.b(0)] = 0 #right_lead[lat.a(0), lat.b(0)] = t_1 #right_lead[lat.a(0), lat.a(1)] = t_2 #syst.attach_lead(right_lead) #right_lead_fin = right_lead.finalized() syst_fin=syst.finalized() return syst_fin, left_lead_fin . def plot_bandstructure(flead, momenta, label=None, title=None): bands = kwant.physics.Bands(flead) energies = [bands(k) for k in momenta] plt.figure() plt.title(title) plt.plot(momenta, energies, label=label) plt.xlabel(&quot;momentum [(lattice constant)^-1]&quot;) plt.ylabel(&quot;energy [t]&quot;) . def plot_conductance(syst, energies): # Compute conductance data = [] for energy in energies: smatrix = kwant.smatrix(syst, energy) data.append(smatrix.transmission(1, 0)) plt.figure() plt.plot(energies, data) plt.xlabel(&quot;energy [t]&quot;) plt.ylabel(&quot;conductance [e^2/h]&quot;) plt.show() . def plot_density(sys,ener, it=-1,title=&quot;empty&quot;): wf = kwant.wave_function(sys, energy=ener) t=np.shape(wf(0)) nwf=wf(0)[0]*0 for i in range(t[0]//2+1): test=wf(0)[i] nwf+=test psi=abs(nwf)**2 if it==-1: title=&quot;density&quot; elif it&gt;-1: title= &quot;density&quot; title2=title+&quot;.pdf&quot; kwant.plotter.map(sys,psi,method=&#39;linear&#39;,vmin=0,title=title) J_0 = kwant.operator.Current(sys) c = J_0(nwf) kwant.plotter.current(sys, c) plt.close() . sys, left_lead = make_system() kwant.plot(sys) for t_2 in np.linspace(0.05, 1, 10): sys, left_lead = make_system(t_1 = 1, t_2 =t_2*0.5j,) plot_bandstructure(left_lead, np.linspace(2,4, 100), t_2, title=f&quot;t_1 = 1, t_2 = {t_2}&quot;) #plot_conductance(sys, np.linspace(0,2,1000)) plot_density(sys, 1,title=f&quot;t_1 = 1, t_2 = {t_2}&quot;) #kwant.plotter.bands(left_lead) plt.show() . TypeError Traceback (most recent call last) &lt;ipython-input-12-1192e6aa8cab&gt; in &lt;module&gt;() 10 plot_bandstructure(left_lead, np.linspace(2,4, 100), t_2, title=f&#34;t_1 = 1, t_2 = {t_2}&#34;) 11 #plot_conductance(sys, np.linspace(0,2,1000)) &gt; 12 plot_density(sys, 1,title=f&#34;t_1 = 1, t_2 = {t_2}&#34;) 13 #kwant.plotter.bands(left_lead) 14 &lt;ipython-input-10-2bdac851c88a&gt; in plot_density(sys, ener, it, title) 110 title2=title+&#34;.pdf&#34; 111 --&gt; 112 kwant.plotter.map(sys,psi,method=&#39;linear&#39;,vmin=0,title=f&#34;t_1 = 1, t_2 = {t_2}&#34;) 113 114 J_0 = kwant.operator.Current(sys) TypeError: map() got an unexpected keyword argument &#39;title&#39; .",
            "url": "https://korsakjakub.github.io/kwant-tutorials-zps/2022/06/07/Lieb.html",
            "relUrl": "/2022/06/07/Lieb.html",
            "date": " • Jun 7, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "SSH model with two atoms in each cell",
            "content": "import kwant from matplotlib import pyplot as plt import tinyarray as ta import numpy as np import scipy.sparse.linalg as sla import scipy . /usr/local/lib/python3.7/dist-packages/kwant/solvers/default.py:18: RuntimeWarning: MUMPS is not available, SciPy built-in solver will be used as a fallback. Performance can be very poor in this case. &#34;Performance can be very poor in this case.&#34;, RuntimeWarning) . This is a tutorial for SSH model 2 atoms in cell . def ssh_model(t_1=1.0, t_2=0.5): L=200 a=1 # Start with an empty tight-binding system and a single square lattice. # `a` is the lattice constant (by default set to 1 for simplicity. syst = kwant.Builder() lat = kwant.lattice.Polyatomic([[2*a, 0]], [[0, 0], [a, 0]]) lat.a, lat.b = lat.sublattices for n in range(L): syst[lat.a(n)] = 0 syst[lat.b(n)] = 0 # Left hopping for n in range(L): syst[lat.a(n), lat.b(n)] = t_1 # Left hopping for n in range(1,L): syst[lat.b(n-1), lat.a(n)] = t_2 leadless=syst leadless=leadless.finalized() leadless=leadless.hamiltonian_submatrix(sparse=True) sym_left_lead = kwant.TranslationalSymmetry([-2*a, 0]) left_lead = kwant.Builder(sym_left_lead) left_lead[lat.a(0)] = 0 left_lead[lat.b(0)] = 0 left_lead[lat.a(0), lat.b(0)] = t_1 left_lead[lat.b(0), lat.a(-1)] = t_2 syst.attach_lead(left_lead) left_lead_fin = left_lead.finalized() sym_right_lead = kwant.TranslationalSymmetry([2*a, 0]) right_lead = kwant.Builder(sym_right_lead) right_lead[lat.a(0)] = 0 right_lead[lat.b(0)] = 0 right_lead[lat.a(0), lat.b(0)] = t_1 right_lead[lat.a(0), lat.a(1)] = t_2 syst.attach_lead(right_lead) right_lead_fin = right_lead.finalized() syst = syst.finalized() return syst, left_lead_fin, right_lead_fin,leadless syst, left_lead, right_lead, leadless= ssh_model() kwant.plot(syst, file=&#39;ssh_2_atoms_in_cell.pdf&#39;) def compute_evs(sys): # Compute some eigenvalues of the closed system sparse_mat = sys.hamiltonian_submatrix(sparse=True) evs = sla.eigs(sparse_mat, 2)[0] print(evs.real) def plot_eigen_energy(): k_tab = np.linspace(0, 2, 200) energies = [] for t2 in k_tab: ham = ssh_model(0.5, t2) e_val, e_vec = scipy.sparse.linalg.eigsh(ham[3], k=16,sigma=0.001,which=&#39;LM&#39;, return_eigenvectors=True) e_val = np.sort(e_val) energies.append(e_val) plt.figure() plt.plot(k_tab, energies) plt.xlabel(&quot;t2&quot;) plt.ylabel(&quot;energy [t]&quot;) def plot_bandstructure(flead, momenta): bands = kwant.physics.Bands(flead) energies = [bands(k) for k in momenta] plt.figure() plt.plot(momenta, energies) plt.xlabel(&quot;momentum [(lattice constant)^-1]&quot;) plt.ylabel(&quot;energy [t]&quot;) plt.savefig(&#39;ssh_energy_bands.pdf&#39;) plt.show() plot_eigen_energy() compute_evs(syst) plot_bandstructure(left_lead, np.linspace(-np.pi, np.pi, 100)) #syst.hamiltonian_submatrix() . [-1.49995915 1.49995915] .",
            "url": "https://korsakjakub.github.io/kwant-tutorials-zps/2022/05/31/SSH_2_atoms_in_cell.html",
            "relUrl": "/2022/05/31/SSH_2_atoms_in_cell.html",
            "date": " • May 31, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Us",
          "content": "These tutorials were made by . Paweł Sidorczak | Tomek Białecki | Krystian Jabłonowski | Jakub Korsak | . from the Faculty of Physics, University of Warsaw. .",
          "url": "https://korsakjakub.github.io/kwant-tutorials-zps/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://korsakjakub.github.io/kwant-tutorials-zps/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}